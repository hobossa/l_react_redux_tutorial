import { createAsyncThunk, createSlice, createSelector, createEntityAdapter } from "@reduxjs/toolkit";
import { client } from "../../api/client";


// we import createEntityAdapter, and call it to create our postsAdapter object.
// We know that we want to keep an array of all post IDs sorted with the newest
// post first, so we pass in a sortComparer function that will sort newer items
// to the front based on the post.date field.
const postsAdapter = createEntityAdapter({
    sortComparer: (a, b) => b.date.localeCompare(a.date)
});

// getInitialState() returns an empty {ids: [], entities: {}} normalized state object.
// Our postsSlice needs to keep the status and error fields for loading state too,
// so we pass those in to getInitialState().
const initialState = postsAdapter.getInitialState({
    status: 'idle',
    error: null,
});

export const fetchPosts = createAsyncThunk(
    'posts/fetchPosts',
    async () => {
        const response = await client.get('/fakeApi/posts');
        return response.data;
    }
);

export const addNewPost = createAsyncThunk(
    'posts/addNewPost',
    async (initialPost) => {
        const response = await client.post('/fakeApi/posts', initialPost);
        return response.data;
    }
);

const postsSlice = createSlice({
    name: 'posts',
    initialState,
    reducers: {
        postUpdated: (state, action) => {
            const { id, title, content } = action.payload;
            //const existingPost = state.posts.find(post => post.id === id);
            const existingPost = state.entities[id];
            if (existingPost) {
                existingPost.title = title;
                existingPost.content = content;
            }
        },
        reactionAdded: (state, action) => {
            const { postId, reaction } = action.payload
            // const existingPost = state.posts.find(post => post.id === postId)
            const existingPost = state.entities[postId];
            if (existingPost) {
                existingPost.reactions[reaction]++
            }
        },
    },
    extraReducers: (builder) => {
        builder
            .addCase(fetchPosts.pending, (state, action) => {
                state.status = 'loading';
            })
            .addCase(fetchPosts.fulfilled, (state, action) => {
                state.status = 'succeeded';
                // state.posts = state.posts.concat(action.payload);

                // Use the `upsertMany` reducer as a mutating update utility

                // use the postsAdapter.upsertMany function to add all of the
                // incoming posts to the state, by passing in the draft state 
                // and the array of posts in action.payload. If there's any 
                // items in action.payload that already existing in our state, 
                // the upsertMany function will merge them together based on 
                // matching IDs.
                // console.log(action);
                postsAdapter.upsertMany(state, action.payload);
            })
            .addCase(fetchPosts.rejected, (state, action) => {
                state.status = 'failed';
                state.error = action.error.message;
            })
            // .addCase(addNewPost.fulfilled, (state, action) => {
            //     state.posts.push(action.payload);
            // });
            // Use the `addOne` reducer for the fulfilled case
            .addCase(addNewPost.fulfilled, postsAdapter.addOne);
    },
})

export const { postAdded, postUpdated, reactionAdded } = postsSlice.actions;

// export const selectAllPosts = (state) => state.posts.posts;

// const post = useSelector(state => state.posts.find(post => post.id === postId));
// export const selectPostById = (id) => (state) => state.posts.find(post => post.id === id);
// export const selectPostById = (state, postId) => state.posts.posts.find(post => post.id === postId);


// Export the customized selectors for this adapter using `getSelectors`
// we can replace the old hand-written selectAllPosts and selectPostById
//  selector functions with the ones generated by postsAdapter.getSelectors.
//  Since the selectors are called with the root Redux state object, 
// they need to know where to find our posts data in the Redux state, 
// so we pass in a small selector that returns state.posts. The generated
// selector functions are always called selectAll and selectById,
// so we can use ES6 destructuring syntax to rename them as we export
// them and match the old selector names. We'll also export selectPostIds 
// the same way, since we want to read the list of sorted post IDs in 
// our <PostsList> component.
export const {
    selectAll: selectAllPosts,
    selectById: selectPostById,
    selectIds: selectPostIds
    // Pass in a selector that returns the posts slice of state
} = postsAdapter.getSelectors(state => state.posts)

export const selectPostByUser = createSelector(
    [selectAllPosts, (state, userId) => userId],
    (posts, userId) => posts.filter(post => post.user === userId)
);

export default postsSlice.reducer;